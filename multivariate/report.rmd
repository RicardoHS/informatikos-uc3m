---
title: "Statistics for Data Science - UC3M Master"
subtitle: "Multivariate Analysis - First Assignment"
author: 
  - "Ricardo Hortelano"
  - "Javier Martinez"
  - "Santiago Raposo"
header-includes:
   - \usepackage{amsmath}
   - \usepackage{bm}
output:
  pdf_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      comment = NA,
                      dev = 'png',
                      dpi = 300)
library(plotly)
library(tidyverse)
library(MASS)
library(pracma)
library(corrplot)
library(GGally)
library(robustbase)
```

```{r poke, include = FALSE, cache = TRUE}
poke <- read_csv("data/pokemon.csv")[,-1] %>% 
  mutate_at(vars(contains("number"), "target", contains("Generation")), as.factor)

poke_long <- poke %>%
  dplyr::select(-target) %>%
  pivot_longer(
    everything(),
    names_to = c("fight", ".value"),
    names_sep = "_"
  )
```


# Part 1 - Pre-process the data set for practical analysis.

## Missing Values
The only columns with missing values is the `poke1_Type.2` and `poke2_Type.2`. These missing values are not real missing values. 
An empty value in this field means that pokemon has not a second type. Knowing this, we treat that empty value as a new category.

Regarding the rest of the dataset, there are no missing values.

## Distribution of Statistics and Outliers
For some of our plots, we are only interested in the distribution of the variables of the pokemons. Since there are two pokemons per row of our dataset, we have joined the distributions of each of the variables in the dataset `poke_long`. After restructuring the dataset in this way, we can see a box plot of the variables so that we can get a rough idea of their distribution.

```{r, cache = TRUE, dependson="poke"}
poke_long %>% 
  select_if(is.numeric) %>% 
  pivot_longer(
    everything(),
    names_to = "Statistic",
    values_to = "Value"
  ) %>% 
  ggplot(aes(x = Statistic, y = Value))+
  geom_boxplot()+
  coord_flip()
```
As we can see, there are some extreme cases atending to the boxplot. Nevertheless we cannot treat this extreme cases as outliers due the fact that a pokemon with extreme values in one variable can have normal values in other variables.

Regarding the fact that we have some knowledge of the structure of our dataset, we might wonder if pokemons which are labeled as `Legendary` are outliers in the distribution of their statistics. We can check this using a pairplot.
```{r, cache=TRUE, dependson="poke", message = F}
numeric_vars <- poke_long %>% 
  select_if(~is.numeric(.) || is.logical(.))
# Take a sample of size = 1000 for plots
numeric_sample <- numeric_vars[sample(nrow(numeric_vars)), ][1:1e3,]
ggpairs(numeric_vars, aes(color = Legendary))
```
As we can observe, the legendary pokemons have larger values in the variables. This is a good indicative that the legendary pokemons can be outliers.

In order to check if these pokemons are outliers or if there can be any other type of outliers in our variables, we employ the False Discovery Rate method. First, we calculate the Mahalanobis distance for the numeric variables in our dataset.
```{r}
n <- nrow(poke)
p <- ncol(poke)
poke_x <- poke_long %>% 
  select_if(is.numeric)
mah_poke <- mahalanobis(poke_x, colMeans(poke_x), cov(poke_x))
plot(sort(mah_poke), main = "Mahalanobis Distance", xlab = "", ylab = "")
```
The extreme cases in the right side can be outliers. In order to check that, we can compute the outliers using the $\chi^2$ distribution test:
```{r}
p_values <- 1 - pchisq(mah_poke, p)
sort_index <- order(p_values)
outliers_index <- sort_index[which(p_values[sort_index] < ((1:n)/n*0.01))]

head(poke_long[outliers_index, ])
```

As there are indeed some outliers, we can try to compute the Mahalanobis distance again using the robust estimators for the sample covariance matrix.
```{r}
mcd_poke <- covMcd(poke_x, alpha = .9)
mah_robust <- mahalanobis(poke_x, mcd_poke$center, mcd_poke$cov)

plot(sort(mah_robust), main = "Mahalanobis Distance (Robust Estimate)", xlab = "", ylab= "")
```

And for the calculation of p-values and detection of outliers:
```{r}
p_values_robust <- 1 - pchisq(mah_robust, p)
sort_index_robust <- order(p_values_robust)
outliers_index_robust <- 
  sort_index_robust[which(p_values_robust[sort_index_robust] < ((1:n)/n*0.01))]

head(poke_long[outliers_index, ])
# Outlier Pokemon
unique(poke_long[outliers_index, ]$Name)
```
But indeed we get the same 3 pokemon showing up as outliers: `Chansey`, `Blissey` and `Shuckle`. The reason these 3 show up as outliers is their extreme values of `HP` (for `Chansey` and `Blissey`) and `Defense` and `Sp.Def` (for `Shuckle`).

We will not be removing these data points, as they are completely fine pokemon, but we will have to make sure that we are using robust estimators in our analyses. This also does reinforce the fact that legendary pokemon are not outliers, as neither `Chansey`, `Blissey` nor `Shuckle` is legendary.

# Part 2 - Perform a descriptive analysis of the pre-processed data set and obtain interesting conclusions from the analysis.
[Insert conclusions here]
